// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_job_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddJobState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddJobStateCopyWith<T, $Res> {
  factory $AddJobStateCopyWith(
          AddJobState<T> value, $Res Function(AddJobState<T>) then) =
      _$AddJobStateCopyWithImpl<T, $Res, AddJobState<T>>;
}

/// @nodoc
class _$AddJobStateCopyWithImpl<T, $Res, $Val extends AddJobState<T>>
    implements $AddJobStateCopyWith<T, $Res> {
  _$AddJobStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<T, $Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl<T> value, $Res Function(_$InitialImpl<T>) then) =
      __$$InitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$InitialImpl<T>>
    implements _$$InitialImplCopyWith<T, $Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl<T> _value, $Res Function(_$InitialImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl<T> implements _Initial<T> {
  const _$InitialImpl();

  @override
  String toString() {
    return 'AddJobState<$T>.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial<T> implements AddJobState<T> {
  const factory _Initial() = _$InitialImpl<T>;
}

/// @nodoc
abstract class _$$AddJobLoadingImplCopyWith<T, $Res> {
  factory _$$AddJobLoadingImplCopyWith(_$AddJobLoadingImpl<T> value,
          $Res Function(_$AddJobLoadingImpl<T>) then) =
      __$$AddJobLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$AddJobLoadingImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$AddJobLoadingImpl<T>>
    implements _$$AddJobLoadingImplCopyWith<T, $Res> {
  __$$AddJobLoadingImplCopyWithImpl(_$AddJobLoadingImpl<T> _value,
      $Res Function(_$AddJobLoadingImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddJobLoadingImpl<T> implements AddJobLoading<T> {
  const _$AddJobLoadingImpl();

  @override
  String toString() {
    return 'AddJobState<$T>.addJobLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AddJobLoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return addJobLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return addJobLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobLoading != null) {
      return addJobLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return addJobLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return addJobLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobLoading != null) {
      return addJobLoading(this);
    }
    return orElse();
  }
}

abstract class AddJobLoading<T> implements AddJobState<T> {
  const factory AddJobLoading() = _$AddJobLoadingImpl<T>;
}

/// @nodoc
abstract class _$$AddJobSuccessImplCopyWith<T, $Res> {
  factory _$$AddJobSuccessImplCopyWith(_$AddJobSuccessImpl<T> value,
          $Res Function(_$AddJobSuccessImpl<T>) then) =
      __$$AddJobSuccessImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$AddJobSuccessImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$AddJobSuccessImpl<T>>
    implements _$$AddJobSuccessImplCopyWith<T, $Res> {
  __$$AddJobSuccessImplCopyWithImpl(_$AddJobSuccessImpl<T> _value,
      $Res Function(_$AddJobSuccessImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddJobSuccessImpl<T> implements AddJobSuccess<T> {
  const _$AddJobSuccessImpl();

  @override
  String toString() {
    return 'AddJobState<$T>.addJobSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AddJobSuccessImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return addJobSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return addJobSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobSuccess != null) {
      return addJobSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return addJobSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return addJobSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobSuccess != null) {
      return addJobSuccess(this);
    }
    return orElse();
  }
}

abstract class AddJobSuccess<T> implements AddJobState<T> {
  const factory AddJobSuccess() = _$AddJobSuccessImpl<T>;
}

/// @nodoc
abstract class _$$AddJobFailureImplCopyWith<T, $Res> {
  factory _$$AddJobFailureImplCopyWith(_$AddJobFailureImpl<T> value,
          $Res Function(_$AddJobFailureImpl<T>) then) =
      __$$AddJobFailureImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$AddJobFailureImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$AddJobFailureImpl<T>>
    implements _$$AddJobFailureImplCopyWith<T, $Res> {
  __$$AddJobFailureImplCopyWithImpl(_$AddJobFailureImpl<T> _value,
      $Res Function(_$AddJobFailureImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$AddJobFailureImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AddJobFailureImpl<T> implements AddJobFailure<T> {
  const _$AddJobFailureImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'AddJobState<$T>.addJobFailure(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddJobFailureImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddJobFailureImplCopyWith<T, _$AddJobFailureImpl<T>> get copyWith =>
      __$$AddJobFailureImplCopyWithImpl<T, _$AddJobFailureImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return addJobFailure(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return addJobFailure?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobFailure != null) {
      return addJobFailure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return addJobFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return addJobFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (addJobFailure != null) {
      return addJobFailure(this);
    }
    return orElse();
  }
}

abstract class AddJobFailure<T> implements AddJobState<T> {
  const factory AddJobFailure({required final String error}) =
      _$AddJobFailureImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$AddJobFailureImplCopyWith<T, _$AddJobFailureImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CategoryAndCityLoadingImplCopyWith<T, $Res> {
  factory _$$CategoryAndCityLoadingImplCopyWith(
          _$CategoryAndCityLoadingImpl<T> value,
          $Res Function(_$CategoryAndCityLoadingImpl<T>) then) =
      __$$CategoryAndCityLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$CategoryAndCityLoadingImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$CategoryAndCityLoadingImpl<T>>
    implements _$$CategoryAndCityLoadingImplCopyWith<T, $Res> {
  __$$CategoryAndCityLoadingImplCopyWithImpl(
      _$CategoryAndCityLoadingImpl<T> _value,
      $Res Function(_$CategoryAndCityLoadingImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CategoryAndCityLoadingImpl<T> implements CategoryAndCityLoading<T> {
  const _$CategoryAndCityLoadingImpl();

  @override
  String toString() {
    return 'AddJobState<$T>.categoryAndCityLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategoryAndCityLoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return categoryAndCityLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return categoryAndCityLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCityLoading != null) {
      return categoryAndCityLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return categoryAndCityLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return categoryAndCityLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCityLoading != null) {
      return categoryAndCityLoading(this);
    }
    return orElse();
  }
}

abstract class CategoryAndCityLoading<T> implements AddJobState<T> {
  const factory CategoryAndCityLoading() = _$CategoryAndCityLoadingImpl<T>;
}

/// @nodoc
abstract class _$$CategoryAndCitySuccessImplCopyWith<T, $Res> {
  factory _$$CategoryAndCitySuccessImplCopyWith(
          _$CategoryAndCitySuccessImpl<T> value,
          $Res Function(_$CategoryAndCitySuccessImpl<T>) then) =
      __$$CategoryAndCitySuccessImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({List<CategoryModel> categoryList, List<CityModel> cityList});
}

/// @nodoc
class __$$CategoryAndCitySuccessImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$CategoryAndCitySuccessImpl<T>>
    implements _$$CategoryAndCitySuccessImplCopyWith<T, $Res> {
  __$$CategoryAndCitySuccessImplCopyWithImpl(
      _$CategoryAndCitySuccessImpl<T> _value,
      $Res Function(_$CategoryAndCitySuccessImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categoryList = null,
    Object? cityList = null,
  }) {
    return _then(_$CategoryAndCitySuccessImpl<T>(
      null == categoryList
          ? _value._categoryList
          : categoryList // ignore: cast_nullable_to_non_nullable
              as List<CategoryModel>,
      null == cityList
          ? _value._cityList
          : cityList // ignore: cast_nullable_to_non_nullable
              as List<CityModel>,
    ));
  }
}

/// @nodoc

class _$CategoryAndCitySuccessImpl<T> implements CategoryAndCitySuccess<T> {
  const _$CategoryAndCitySuccessImpl(
      final List<CategoryModel> categoryList, final List<CityModel> cityList)
      : _categoryList = categoryList,
        _cityList = cityList;

  final List<CategoryModel> _categoryList;
  @override
  List<CategoryModel> get categoryList {
    if (_categoryList is EqualUnmodifiableListView) return _categoryList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categoryList);
  }

  final List<CityModel> _cityList;
  @override
  List<CityModel> get cityList {
    if (_cityList is EqualUnmodifiableListView) return _cityList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_cityList);
  }

  @override
  String toString() {
    return 'AddJobState<$T>.categoryAndCitySuccess(categoryList: $categoryList, cityList: $cityList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategoryAndCitySuccessImpl<T> &&
            const DeepCollectionEquality()
                .equals(other._categoryList, _categoryList) &&
            const DeepCollectionEquality().equals(other._cityList, _cityList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_categoryList),
      const DeepCollectionEquality().hash(_cityList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CategoryAndCitySuccessImplCopyWith<T, _$CategoryAndCitySuccessImpl<T>>
      get copyWith => __$$CategoryAndCitySuccessImplCopyWithImpl<T,
          _$CategoryAndCitySuccessImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return categoryAndCitySuccess(categoryList, cityList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return categoryAndCitySuccess?.call(categoryList, cityList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCitySuccess != null) {
      return categoryAndCitySuccess(categoryList, cityList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return categoryAndCitySuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return categoryAndCitySuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCitySuccess != null) {
      return categoryAndCitySuccess(this);
    }
    return orElse();
  }
}

abstract class CategoryAndCitySuccess<T> implements AddJobState<T> {
  const factory CategoryAndCitySuccess(final List<CategoryModel> categoryList,
      final List<CityModel> cityList) = _$CategoryAndCitySuccessImpl<T>;

  List<CategoryModel> get categoryList;
  List<CityModel> get cityList;
  @JsonKey(ignore: true)
  _$$CategoryAndCitySuccessImplCopyWith<T, _$CategoryAndCitySuccessImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CategoryAndCityFailureImplCopyWith<T, $Res> {
  factory _$$CategoryAndCityFailureImplCopyWith(
          _$CategoryAndCityFailureImpl<T> value,
          $Res Function(_$CategoryAndCityFailureImpl<T>) then) =
      __$$CategoryAndCityFailureImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$CategoryAndCityFailureImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$CategoryAndCityFailureImpl<T>>
    implements _$$CategoryAndCityFailureImplCopyWith<T, $Res> {
  __$$CategoryAndCityFailureImplCopyWithImpl(
      _$CategoryAndCityFailureImpl<T> _value,
      $Res Function(_$CategoryAndCityFailureImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$CategoryAndCityFailureImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CategoryAndCityFailureImpl<T> implements CategoryAndCityFailure<T> {
  const _$CategoryAndCityFailureImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'AddJobState<$T>.categoryAndCityFailure(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategoryAndCityFailureImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CategoryAndCityFailureImplCopyWith<T, _$CategoryAndCityFailureImpl<T>>
      get copyWith => __$$CategoryAndCityFailureImplCopyWithImpl<T,
          _$CategoryAndCityFailureImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return categoryAndCityFailure(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return categoryAndCityFailure?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCityFailure != null) {
      return categoryAndCityFailure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return categoryAndCityFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return categoryAndCityFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryAndCityFailure != null) {
      return categoryAndCityFailure(this);
    }
    return orElse();
  }
}

abstract class CategoryAndCityFailure<T> implements AddJobState<T> {
  const factory CategoryAndCityFailure({required final String error}) =
      _$CategoryAndCityFailureImpl<T>;

  String get error;
  @JsonKey(ignore: true)
  _$$CategoryAndCityFailureImplCopyWith<T, _$CategoryAndCityFailureImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateStepsImplCopyWith<T, $Res> {
  factory _$$UpdateStepsImplCopyWith(_$UpdateStepsImpl<T> value,
          $Res Function(_$UpdateStepsImpl<T>) then) =
      __$$UpdateStepsImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$UpdateStepsImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$UpdateStepsImpl<T>>
    implements _$$UpdateStepsImplCopyWith<T, $Res> {
  __$$UpdateStepsImplCopyWithImpl(
      _$UpdateStepsImpl<T> _value, $Res Function(_$UpdateStepsImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$UpdateStepsImpl<T>(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UpdateStepsImpl<T> implements UpdateSteps<T> {
  const _$UpdateStepsImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddJobState<$T>.updateSteps(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateStepsImpl<T> &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateStepsImplCopyWith<T, _$UpdateStepsImpl<T>> get copyWith =>
      __$$UpdateStepsImplCopyWithImpl<T, _$UpdateStepsImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return updateSteps(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return updateSteps?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (updateSteps != null) {
      return updateSteps(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return updateSteps(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return updateSteps?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (updateSteps != null) {
      return updateSteps(this);
    }
    return orElse();
  }
}

abstract class UpdateSteps<T> implements AddJobState<T> {
  const factory UpdateSteps({required final int index}) = _$UpdateStepsImpl<T>;

  int get index;
  @JsonKey(ignore: true)
  _$$UpdateStepsImplCopyWith<T, _$UpdateStepsImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CategoryIndexUpdatedImplCopyWith<T, $Res> {
  factory _$$CategoryIndexUpdatedImplCopyWith(
          _$CategoryIndexUpdatedImpl<T> value,
          $Res Function(_$CategoryIndexUpdatedImpl<T>) then) =
      __$$CategoryIndexUpdatedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$CategoryIndexUpdatedImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$CategoryIndexUpdatedImpl<T>>
    implements _$$CategoryIndexUpdatedImplCopyWith<T, $Res> {
  __$$CategoryIndexUpdatedImplCopyWithImpl(_$CategoryIndexUpdatedImpl<T> _value,
      $Res Function(_$CategoryIndexUpdatedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$CategoryIndexUpdatedImpl<T>(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CategoryIndexUpdatedImpl<T> implements CategoryIndexUpdated<T> {
  const _$CategoryIndexUpdatedImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddJobState<$T>.categoryIndexUpdated(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CategoryIndexUpdatedImpl<T> &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CategoryIndexUpdatedImplCopyWith<T, _$CategoryIndexUpdatedImpl<T>>
      get copyWith => __$$CategoryIndexUpdatedImplCopyWithImpl<T,
          _$CategoryIndexUpdatedImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return categoryIndexUpdated(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return categoryIndexUpdated?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryIndexUpdated != null) {
      return categoryIndexUpdated(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return categoryIndexUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return categoryIndexUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (categoryIndexUpdated != null) {
      return categoryIndexUpdated(this);
    }
    return orElse();
  }
}

abstract class CategoryIndexUpdated<T> implements AddJobState<T> {
  const factory CategoryIndexUpdated({required final int index}) =
      _$CategoryIndexUpdatedImpl<T>;

  int get index;
  @JsonKey(ignore: true)
  _$$CategoryIndexUpdatedImplCopyWith<T, _$CategoryIndexUpdatedImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CityIndexUpdatedImplCopyWith<T, $Res> {
  factory _$$CityIndexUpdatedImplCopyWith(_$CityIndexUpdatedImpl<T> value,
          $Res Function(_$CityIndexUpdatedImpl<T>) then) =
      __$$CityIndexUpdatedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$CityIndexUpdatedImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$CityIndexUpdatedImpl<T>>
    implements _$$CityIndexUpdatedImplCopyWith<T, $Res> {
  __$$CityIndexUpdatedImplCopyWithImpl(_$CityIndexUpdatedImpl<T> _value,
      $Res Function(_$CityIndexUpdatedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$CityIndexUpdatedImpl<T>(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$CityIndexUpdatedImpl<T> implements CityIndexUpdated<T> {
  const _$CityIndexUpdatedImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddJobState<$T>.cityIndexUpdated(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CityIndexUpdatedImpl<T> &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CityIndexUpdatedImplCopyWith<T, _$CityIndexUpdatedImpl<T>> get copyWith =>
      __$$CityIndexUpdatedImplCopyWithImpl<T, _$CityIndexUpdatedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return cityIndexUpdated(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return cityIndexUpdated?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (cityIndexUpdated != null) {
      return cityIndexUpdated(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return cityIndexUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return cityIndexUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (cityIndexUpdated != null) {
      return cityIndexUpdated(this);
    }
    return orElse();
  }
}

abstract class CityIndexUpdated<T> implements AddJobState<T> {
  const factory CityIndexUpdated({required final int index}) =
      _$CityIndexUpdatedImpl<T>;

  int get index;
  @JsonKey(ignore: true)
  _$$CityIndexUpdatedImplCopyWith<T, _$CityIndexUpdatedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StepUpdatedImplCopyWith<T, $Res> {
  factory _$$StepUpdatedImplCopyWith(_$StepUpdatedImpl<T> value,
          $Res Function(_$StepUpdatedImpl<T>) then) =
      __$$StepUpdatedImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$StepUpdatedImplCopyWithImpl<T, $Res>
    extends _$AddJobStateCopyWithImpl<T, $Res, _$StepUpdatedImpl<T>>
    implements _$$StepUpdatedImplCopyWith<T, $Res> {
  __$$StepUpdatedImplCopyWithImpl(
      _$StepUpdatedImpl<T> _value, $Res Function(_$StepUpdatedImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$StepUpdatedImpl<T>(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$StepUpdatedImpl<T> implements StepUpdated<T> {
  const _$StepUpdatedImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'AddJobState<$T>.stepUpdated(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StepUpdatedImpl<T> &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StepUpdatedImplCopyWith<T, _$StepUpdatedImpl<T>> get copyWith =>
      __$$StepUpdatedImplCopyWithImpl<T, _$StepUpdatedImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() addJobLoading,
    required TResult Function() addJobSuccess,
    required TResult Function(String error) addJobFailure,
    required TResult Function() categoryAndCityLoading,
    required TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)
        categoryAndCitySuccess,
    required TResult Function(String error) categoryAndCityFailure,
    required TResult Function(int index) updateSteps,
    required TResult Function(int index) categoryIndexUpdated,
    required TResult Function(int index) cityIndexUpdated,
    required TResult Function(int index) stepUpdated,
  }) {
    return stepUpdated(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? addJobLoading,
    TResult? Function()? addJobSuccess,
    TResult? Function(String error)? addJobFailure,
    TResult? Function()? categoryAndCityLoading,
    TResult? Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult? Function(String error)? categoryAndCityFailure,
    TResult? Function(int index)? updateSteps,
    TResult? Function(int index)? categoryIndexUpdated,
    TResult? Function(int index)? cityIndexUpdated,
    TResult? Function(int index)? stepUpdated,
  }) {
    return stepUpdated?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? addJobLoading,
    TResult Function()? addJobSuccess,
    TResult Function(String error)? addJobFailure,
    TResult Function()? categoryAndCityLoading,
    TResult Function(
            List<CategoryModel> categoryList, List<CityModel> cityList)?
        categoryAndCitySuccess,
    TResult Function(String error)? categoryAndCityFailure,
    TResult Function(int index)? updateSteps,
    TResult Function(int index)? categoryIndexUpdated,
    TResult Function(int index)? cityIndexUpdated,
    TResult Function(int index)? stepUpdated,
    required TResult orElse(),
  }) {
    if (stepUpdated != null) {
      return stepUpdated(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(AddJobLoading<T> value) addJobLoading,
    required TResult Function(AddJobSuccess<T> value) addJobSuccess,
    required TResult Function(AddJobFailure<T> value) addJobFailure,
    required TResult Function(CategoryAndCityLoading<T> value)
        categoryAndCityLoading,
    required TResult Function(CategoryAndCitySuccess<T> value)
        categoryAndCitySuccess,
    required TResult Function(CategoryAndCityFailure<T> value)
        categoryAndCityFailure,
    required TResult Function(UpdateSteps<T> value) updateSteps,
    required TResult Function(CategoryIndexUpdated<T> value)
        categoryIndexUpdated,
    required TResult Function(CityIndexUpdated<T> value) cityIndexUpdated,
    required TResult Function(StepUpdated<T> value) stepUpdated,
  }) {
    return stepUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(AddJobLoading<T> value)? addJobLoading,
    TResult? Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult? Function(AddJobFailure<T> value)? addJobFailure,
    TResult? Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult? Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult? Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult? Function(UpdateSteps<T> value)? updateSteps,
    TResult? Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult? Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult? Function(StepUpdated<T> value)? stepUpdated,
  }) {
    return stepUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(AddJobLoading<T> value)? addJobLoading,
    TResult Function(AddJobSuccess<T> value)? addJobSuccess,
    TResult Function(AddJobFailure<T> value)? addJobFailure,
    TResult Function(CategoryAndCityLoading<T> value)? categoryAndCityLoading,
    TResult Function(CategoryAndCitySuccess<T> value)? categoryAndCitySuccess,
    TResult Function(CategoryAndCityFailure<T> value)? categoryAndCityFailure,
    TResult Function(UpdateSteps<T> value)? updateSteps,
    TResult Function(CategoryIndexUpdated<T> value)? categoryIndexUpdated,
    TResult Function(CityIndexUpdated<T> value)? cityIndexUpdated,
    TResult Function(StepUpdated<T> value)? stepUpdated,
    required TResult orElse(),
  }) {
    if (stepUpdated != null) {
      return stepUpdated(this);
    }
    return orElse();
  }
}

abstract class StepUpdated<T> implements AddJobState<T> {
  const factory StepUpdated({required final int index}) = _$StepUpdatedImpl<T>;

  int get index;
  @JsonKey(ignore: true)
  _$$StepUpdatedImplCopyWith<T, _$StepUpdatedImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
